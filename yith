#!/usr/bin/env node

// Copyright (c) 2013 Alejandro Blanco <alejandro.b.e@gmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
// the Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

(function () {
    "use strict";

    var program = require("commander"),
        prompt = require("prompt"),
        fs = require("fs"),
        zlib = require("zlib"),
        sjcl = require("sjcl"),
        promptSchema,
        string,
        createEntry,
        parseCSV,
        list,
        search,
        decipher,
        view,
        importLastpass,
        secretsFile;

    promptSchema = {
        properties: {
            password: { hidden: true }
        }
    };

    // FUNCTIONS
    string = function (val) {
        return String(val);
    };

    createEntry = function (service, account, secret, tags, notes, expiration) {
        var expiration = expiration || 0,
            tags = tags instanceof Array ? tags : (tags ? [tags] : []),
            notes = notes || '',
            entry = {
                service: service,
                account: account,
                secret: secret,
                tags: tags,
                notes: notes,
                expiration: expiration
            };
        return entry;
    };

    // Taken from http://stackoverflow.com/a/1293163/2343
    parseCSV = function (csvStr, delimiter) {
        var objPattern, output, matches, matchedDelimiter, strMatchedValue;

        delimiter = (delimiter || ",");
        objPattern = new RegExp(
            (
                // Delimiters
                "(\\" + delimiter + "|\\r?\\n|\\r|^)" +
                // Quoted fields
                "(?:\"([^\"]*(?:\"\"[^\"]*)*)\"|" +
                // Standard fields
                "([^\"\\" + delimiter + "\\r\\n]*))"
            ),
            "gi"
        );
        output = [[]];
        matches = null;
        matchedDelimiter = '';
        strMatchedValue = null;

        // Keep looping over the regular expression matches
        // until we can no longer find a match
        while (matches = objPattern.exec(string(csvStr).trim())) {
            matchedDelimiter = matches[1];

            // Check to see if the given delimiter has a length
            // (is not the start of string) and if it matches
            // field delimiter. If id does not, then we know
            // that this delimiter is a row delimiter
            if (matchedDelimiter.length && matchedDelimiter !== delimiter) {
                // new row of data, add an empty row to the output
                output.push([]);
            }

            if (matches[2]) {
                // quoted value, unescape any double quotes
                strMatchedValue = matches[2].replace(
                    new RegExp("\"\"", "g"),
                    "\""
                );
            } else {
                // non-quoted value
                strMatchedValue = matches[3];
            }

            output[output.length-1].push(strMatchedValue);
        }

        // Return the parsed data.
        return output;
    };

    list = function (secrets) {
        var output, i, s;

        for (i = 0; i < secrets.length; i += 1) {
            s = secrets[i];
            output = "[";
            if (s.originalIndex) {
                output += s.originalIndex + 1;
            } else {
                output += (i + 1);
            }
            console.log(output + "] " + s.service + " / " + s.account);
        }
    };

    search = function (secrets, keyword) {
        var matches = [],
            i,
            s;

        keyword = keyword.toLowerCase();

        for (i = 0; i < secrets.length; i += 1) {
            s = secrets[i];
            s.serviceLC = s.service ? s.service.toLowerCase() : "";
            s.accountLC = s.account ? s.account.toLowerCase() : "";
            s.notesLC = s.notes ? s.notes.toLowerCase() : "";
            if (s.serviceLC.indexOf(keyword) >= 0 ||
                    s.accountLC.indexOf(keyword) >= 0 ||
                    s.notesLC.indexOf(keyword) >= 0) {
                s.originalIndex = i;
                matches.push(s);
            }
        }

        list(matches);
    };

    decipher = function (secrets, toDecipher) {
        var data;

        if (toDecipher < 1 || toDecipher > secrets.length) {
            console.log("That secret doesn't exist, please enter a valid number");
        }
        data = secrets[toDecipher - 1];

        prompt.start();
        prompt.get(promptSchema, function (error, input) {
            var plain;

            try {
                plain = sjcl.decrypt(input.password, data.secret);
                console.log(plain);
            } catch (err) {
                console.log("Wrong master password");
            }

            plain = input = null;
        });
    };

    view = function (secrets, toShow) {
        var data,
            output,
            i;

        if (toShow < 1 || toShow > secrets.length) {
            console.log("That secret doesn't exist, please enter a valid number");
        }
        data = secrets[toShow - 1];

        output = "Service: " + data.service + "\nAccount: " + data.account +
            "\nTags: ";
        for (i = 0; i < data.tags.length; i += 1) {
            output += data.tags[i];
            if (i !== data.tags.length - 1) {
                output += ", ";
            }
        }
        output += "\nExpiration: " + data.expiration;
        if (data.notes !== "") {
            output += "\nNotes:\n" + data.notes;
        }

        console.log(output);
    };

    importLastpass = function (lastpassFile, outputFile) {
        console.log("Processing Lastpass export file: " + lastpassFile);

        // Lastpass export is a CSV with these columns:
        //     url,username,password,extra,name,grouping,favorite
        // Exported file can have a trailing empty line that has to be trimmed.
        var lastpassCSVStr = fs.readFileSync(lastpassFile),
            lastpassData = parseCSV(lastpassCSVStr, ','),
            yithData = [],
            lastpassEntry,
            yithEntry;

        console.log("Enter master password to use to encrypt secrets in Yith");

        prompt.start();
        prompt.get(promptSchema, function (error, input) {
            var url,
                username,
                password,
                extra,
                name,
                grouping,
                favorite,
                i;

            for (i = 1; i < lastpassData.length; i += 1) {
                lastpassEntry = lastpassData[i];
                url = lastpassEntry[0];
                username = lastpassEntry[1];
                password = lastpassEntry[2];
                extra = lastpassEntry[3];
                name = lastpassEntry[4];
                grouping = [lastpassEntry[5]];
                favorite = lastpassEntry[6];
                if (url === "http://sn") {
                    // Secure note, secret is in extra
                    password = extra;
                    extra = "";
                    grouping.push("Notes");
                } else {
                    // In other cases keep the original URL
                    extra = JSON.stringify({
                        url: url,
                        extra: extra
                    });
                }
                if (favorite === "1") {
                    grouping.push("Favorites");
                }
                yithEntry = createEntry(
                    name, // service
                    username, // account
                    sjcl.encrypt(input.password, password), // secret
                    grouping, // tags
                    extra // notes
                );
                yithData.push(yithEntry);
            }

            input = null;

            // write Yith backup file in gzipped JSON format
            zlib.gzip(JSON.stringify(yithData),
                      function(error, result) {
                          fs.writeFileSync(outputFile, result);
                      });
        });
    };

    // MAIN

    program
        .version("0.2.2")
        .usage("[options] <backup_file>")
        .option("-l, --list", "List passwords")
        .option("-s, --search <keyword>", "Search secrets", string)
        .option("-d, --decipher <service_number>", "Decipher a secret", parseInt)
        .option("-v, --view <service_number>", "Show a secret details", parseInt)
        .option("--import-lastpass <lastpass_csv_export>", "Import passwords from Lastpass", string)
        .parse(process.argv);

    if (program.args.length !== 1) {
        console.log("Wrong number of arguments");
        console.log("Usage: " + program._usage);
        return;
    }

    if (program.importLastpass) {
        importLastpass(program.importLastpass, program.args[0]);
        return;
    }

    try {
        secretsFile = fs.readFileSync(program.args[0]);
        secretsFile = zlib.unzip(secretsFile, function (err, buffer) {
            var secrets = JSON.parse(buffer.toString()),
                hadOptions = false;

            if (err) {
                console.log(err);
                return;
            }

            if (program.list) {
                hadOptions = true;
                list(secrets);
            }

            if (program.search) {
                hadOptions = true;
                search(secrets, program.search);
            }

            if (program.decipher) {
                hadOptions = true;
                decipher(secrets, program.decipher);
            }

            if (program.view) {
                hadOptions = true;
                view(secrets, program.view);
            }

            if (!hadOptions) {
                list(secrets);
            }
        });
    } catch (err) {
        console.log("An error was encountered reading the file: " + program.args[0]);
        console.log(err.message);
    }
}());
